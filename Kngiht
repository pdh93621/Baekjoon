#include <iostream>
#include <vector>
#define EMPTY 0
using namespace std;

int dm[8] = { 1,1,-1,-1,2,2,-2,-2 };
int dn[8] = { 2,-2,2,-2,1,-1,1,-1 };

typedef struct Node {
	int m;
	int n;
	struct Node* link;
}Queue;

Queue* GetNode() {
	Queue* NewA;
	NewA = (Queue*)malloc(sizeof(Queue));
	NewA->link = EMPTY;
	return NewA;
}

void Push(Queue** Head, Queue** Rear, int m, int n) {
	if (*Head) {
		(*Rear)->link = GetNode();
		*Rear = (*Rear)->link;
		(*Rear)->m = m;
		(*Rear)->n = n;
	}
	else {
		*Head = GetNode();
		*Rear = *Head;
		(*Rear)->m = m;
		(*Rear)->n = n;
	}
}

void Pop(Queue** Head) {
	if (*Head) {
		Queue* temp;
		temp = *Head;
		*Head = (*Head)->link;
		free(temp);
	}
}
void Destroy(Queue** Head) {
	if (*Head) {
		Pop(Head);
		Destroy(Head);
	}
}

int Top_m(Queue** Head) {
	return (*Head)->m;
}
int Top_n(Queue** Head) {
	return (*Head)->n;
}

int func(Queue** Head,Queue** Rear, vector<vector<int>>& visited, int m, int n, int end[], int I) {
	int nm;
	int nn;
	if (m == end[0] && n == end[1]) {
		return 0;
	}
	Push(Head, Rear, m, n);
	visited[m][n] = 1;
	while (*Head) {
		for (int i = 0; i < 8; i++) {
			nm = Top_m(Head) + dm[i];
			nn = Top_n(Head) + dn[i];
			if (nm >= 0 && nm < I && nn >= 0 && nn < I) {
				if (!visited[nm][nn]) {
					if (nm == end[0] && nn == end[1]) {
						return visited[Top_m(Head)][Top_n(Head)];						
					}
					visited[nm][nn] = visited[Top_m(Head)][Top_n(Head)] + 1;
					
					Push(Head, Rear, nm, nn);					
				}
			}
		}
		Pop(Head);
	}
}

int main() {
	Queue* Head = EMPTY;
	Queue* Rear = EMPTY;
	int N;
	cin >> N;
	int I = 0;
	int begin[2] = { 0 };
	int end[2] = { 0 };

	for (int i = 0; i < N; i++) {
		cin >> I;
		cin >> begin[0];
		cin >> begin[1];
		cin >> end[0];
		cin >> end[1];

		vector<vector<int>> visited(I, vector<int>(I, 0));
	
		cout << func(&Head, &Rear, visited, begin[0], begin[1], end, I) <<endl;
		
		Destroy(&Head);
	}
	return 0;
}
